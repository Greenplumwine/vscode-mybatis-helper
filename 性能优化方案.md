# MyBatis Helper 插件性能优化方案

## 1. 项目现状分析

MyBatis Helper 是一款专为 MyBatis 开发者设计的 VSCode 插件，提供了控制台日志拦截、SQL 转换以及文件快速跳转等功能。经过对项目代码的分析，发现当前插件在文件映射和跳转方面存在以下可优化点：

1. **文件扫描效率**：当前实现主要通过正则表达式和文件系统操作进行扫描，在大型项目中可能影响性能
2. **缓存机制**：虽有基本缓存，但可进一步优化缓存策略和失效机制
3. **资源利用**：未充分利用 VSCode 的 Java 扩展 API 提供的功能
4. **查找算法**：可改进文件查找算法，实现更精确和高效的匹配

## 2. 混合优化方案概述

基于对现有方案和新思路的综合分析，我们提出一个混合优化方案，结合两者的优势：

1. **优先集成 VSCode Java 扩展 API**：作为首选的文件查找手段，充分利用其准确性和性能优势
2. **保留并优化缓存机制**：维持多层级缓存和 LRU 淘汰策略，确保性能
3. **改进文件扫描策略**：使用增量扫描和并行处理提升效率
4. **索引机制**：维持 O(1) 时间复杂度的映射查找
5. **条件性降级机制**：在 Java 扩展不可用或查找失败时，降级使用传统查找方式作为备选方案

## 3. 优化目标

1. 提升大型项目（1000+ 文件）中文件映射和跳转的性能
2. 优化首次加载和扫描的时间
3. 减少内存占用
4. 提供更流畅的用户体验
5. 确保在各种项目结构下的兼容性
6. 充分利用 VSCode Java 扩展 API 提升查找准确性
7. 保持在无 Java 扩展环境下的基本功能可用性

## 3. 详细优化方案

### 3.1 优先集成 VSCode Java 扩展 API

通过集成 VSCode 的 Java 扩展 API，可以直接获取项目的结构信息，避免手动扫描文件，大幅提升性能。Java 扩展 API 将作为首选的文件查找手段，充分利用其准确性和性能优势。只有在 Java 扩展不可用或查找失败时，才会降级使用传统查找方式作为备选方案，以确保在各种环境下插件仍能正常工作。

```typescript
/**
 * Java 扩展 API 集成模块
 */
export class JavaExtensionAPI {
  private static instance: JavaExtensionAPI;
  private javaExtApi: any = null;
  private extensionContext: vscode.ExtensionContext;
  private isActivated: boolean = false;

  private constructor() {}

  public static getInstance(): JavaExtensionAPI {
    if (!JavaExtensionAPI.instance) {
      JavaExtensionAPI.instance = new JavaExtensionAPI();
    }
    return JavaExtensionAPI.instance;
  }

  /**
   * 初始化 Java 扩展 API 连接
   */
  public async initialize(context: vscode.ExtensionContext): Promise<void> {
    this.extensionContext = context;
    
    // 尝试激活并获取 Java 扩展 API
    try {
      const javaExt = vscode.extensions.getExtension('redhat.java');
      if (javaExt) {
        if (!javaExt.isActive) {
          await javaExt.activate();
        }
        this.javaExtApi = javaExt.exports;
        this.isActivated = true;
      }
    } catch (error) {
      console.error('Failed to initialize Java Extension API:', error);
    }
  }

  /**
   * 检查 Java 扩展 API 是否已激活
   */
  public get isReady(): boolean {
    return this.isActivated && this.javaExtApi !== null;
  }

  /**
   * 获取项目中的所有 Mapper 接口
   */
  public async getMapperInterfaces(): Promise<Array<{ className: string, filePath: string }>> {
    if (!this.isReady) {
      return [];
    }
    
    try {
      // 使用 Java 扩展 API 获取项目中的接口信息
      const allInterfaces = await this.javaExtApi.listInterfaces();
      
      // 筛选出 Mapper 接口（通过注解或导入判断）
      return allInterfaces.filter((iface: any) => {
        return iface.annotations.some((anno: any) => anno.name.includes('Mapper')) ||
               iface.imports.some((imp: any) => imp.includes('Mapper'));
      }).map((iface: any) => ({
        className: iface.name,
        filePath: iface.filePath
      }));
    } catch (error) {
      console.error('Failed to get mapper interfaces:', error);
      return [];
    }
  }

  /**
   * 通过类名查找对应的 Java 文件
   */
  public async findJavaFileByClassName(className: string): Promise<string | undefined> {
    if (!this.isReady) {
      return undefined;
    }
    
    try {
      const result = await this.javaExtApi.findType(className);
      return result?.filePath;
    } catch (error) {
      console.error(`Failed to find Java file for class ${className}:`, error);
      return undefined;
    }
  }

  /**
   * 获取类的资源路径
   */
  public async getResourcePathForClass(className: string): Promise<string | undefined> {
    if (!this.isReady) {
      return undefined;
    }
    
    try {
      // 使用 Java 扩展 API 获取类的编译信息和资源路径
      const classInfo = await this.javaExtApi.getTypeInfo(className);
      return classInfo?.resourcePath;
    } catch (error) {
      console.error(`Failed to get resource path for class ${className}:`, error);
      return undefined;
    }
  }
}
```

### 3.1.1 Java 扩展 API 使用策略

1. **优先使用**：在 Java 扩展可用时，优先使用其 API 进行文件查找，充分利用其准确性和性能优势
2. **条件性降级**：当 Java 扩展不可用或查找失败时，自动降级到传统查找方式作为备选方案
3. **缓存结合**：将 Java 扩展 API 的查找结果与缓存机制结合，进一步提升性能

### 3.2 优化缓存机制

实现多层级缓存策略，根据数据类型和访问模式设置不同的缓存过期时间，并添加 LRU 缓存淘汰策略。缓存机制是性能优化的核心组件之一，移除缓存会导致频繁的文件系统操作和 API 调用，严重影响性能。我们将保留并进一步优化缓存机制。

```typescript
/**
 * 高级缓存管理器
 */
export class AdvancedCacheManager {
  private static instance: AdvancedCacheManager;
  private caches: Map<string, CacheLayer> = new Map();
  private defaultMaxSize: number = 1000;
  private defaultTTL: number = 30 * 60 * 1000; // 默认 30 分钟

  private constructor() {
    // 初始化不同类型的缓存
    this.caches.set('fileMappings', new CacheLayer('fileMappings', this.defaultMaxSize, this.defaultTTL));
    this.caches.set('javaToXml', new CacheLayer('javaToXml', this.defaultMaxSize, this.defaultTTL));
    this.caches.set('xmlToJava', new CacheLayer('xmlToJava', this.defaultMaxSize, this.defaultTTL));
    this.caches.set('quickPath', new CacheLayer('quickPath', 500, 10 * 60 * 1000)); // 10 分钟
    this.caches.set('resourcePath', new CacheLayer('resourcePath', 500, 15 * 60 * 1000)); // 15 分钟
  }

  public static getInstance(): AdvancedCacheManager {
    if (!AdvancedCacheManager.instance) {
      AdvancedCacheManager.instance = new AdvancedCacheManager();
    }
    return AdvancedCacheManager.instance;
  }

  /**
   * 获取指定类型的缓存
   */
  public getCache(cacheType: string): CacheLayer | undefined {
    return this.caches.get(cacheType);
  }

  /**
   * 清除所有缓存
   */
  public clearAll(): void {
    for (const cache of this.caches.values()) {
      cache.clear();
    }
  }

  /**
   * 清除指定类型的缓存
   */
  public clearCache(cacheType: string): void {
    const cache = this.getCache(cacheType);
    if (cache) {
      cache.clear();
    }
  }
}

/**
 * 缓存层实现，支持 LRU 淘汰策略
 */
export class CacheLayer {
  private cache: Map<string, CacheItem> = new Map();
  private accessOrder: string[] = [];
  private maxSize: number;
  private ttl: number;
  private name: string;

  constructor(name: string, maxSize: number, ttl: number) {
    this.name = name;
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  /**
   * 设置缓存项
   */
  public set(key: string, value: any): void {
    // 检查是否达到最大大小，如果是则移除最久未使用的项
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      if (this.accessOrder.length > 0) {
        const oldestKey = this.accessOrder.shift();
        if (oldestKey) {
          this.cache.delete(oldestKey);
        }
      }
    }

    // 更新访问顺序
    this.updateAccessOrder(key);
    
    // 设置缓存项
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }

  /**
   * 获取缓存项
   */
  public get(key: string): any | undefined {
    const item = this.cache.get(key);
    if (!item) {
      return undefined;
    }

    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return undefined;
    }

    // 更新访问顺序
    this.updateAccessOrder(key);
    
    return item.value;
  }

  /**
   * 检查缓存中是否存在指定键
   */
  public has(key: string): boolean {
    return this.get(key) !== undefined;
  }

  /**
   * 删除缓存项
   */
  public delete(key: string): void {
    this.cache.delete(key);
    const index = this.accessOrder.indexOf(key);
    if (index > -1) {
      this.accessOrder.splice(index, 1);
    }
  }

  /**
   * 清除缓存
   */
  public clear(): void {
    this.cache.clear();
    this.accessOrder = [];
  }

  /**
   * 获取缓存大小
   */
  public get size(): number {
    return this.cache.size;
  }

  /**
   * 更新访问顺序
   */
  private updateAccessOrder(key: string): void {
    // 移除旧位置
    const index = this.accessOrder.indexOf(key);
    if (index > -1) {
      this.accessOrder.splice(index, 1);
    }
    // 添加到末尾
    this.accessOrder.push(key);
  }
}

interface CacheItem {
  value: any;
  timestamp: number;
}
```

### 3.2.1 缓存优化策略

1. **多层级缓存**：根据数据访问频率和重要性设置不同层级的缓存
2. **智能 TTL**：根据数据类型设置合理的过期时间
3. **LRU 淘汰**：确保热点数据常驻缓存，冷数据及时清理
4. **缓存预热**：在插件启动时预加载常用数据到缓存
5. **缓存与 Java API 结合**：将 Java 扩展 API 的查找结果缓存，避免重复调用

### 3.3 改进文件扫描策略

实现增量扫描算法和并行扫描，只扫描变化的文件和相关依赖，大幅提高扫描效率。通过增量扫描，我们避免了对未修改文件的重复处理；通过并行扫描，我们充分利用多核 CPU 的计算能力，进一步提升扫描速度。

```typescript
/**
 * 增量扫描器实现
 */
export class IncrementalScanner {
  private static instance: IncrementalScanner;
  private projectRoots: Set<string> = new Set();
  private scannedFiles: Map<string, number> = new Map(); // 文件路径 -> 上次修改时间
  private scanQueue: Set<string> = new Set();
  private isScanning: boolean = false;
  private readonly batchSize: number = 50;
  private readonly maxConcurrentTasks: number = 5;

  private constructor() {}

  public static getInstance(): IncrementalScanner {
    if (!IncrementalScanner.instance) {
      IncrementalScanner.instance = new IncrementalScanner();
    }
    return IncrementalScanner.instance;
  }

  /**
   * 添加项目根目录
   */
  public addProjectRoot(rootPath: string): void {
    this.projectRoots.add(rootPath);
  }

  /**
   * 添加文件到扫描队列
   */
  public addFileToQueue(filePath: string): void {
    this.scanQueue.add(filePath);
    this.scheduleScan();
  }

  /**
   * 调度扫描任务
   */
  private scheduleScan(): void {
    if (this.isScanning || this.scanQueue.size === 0) {
      return;
    }

    this.isScanning = true;
    
    // 处理一批文件
    this.processNextBatch().finally(() => {
      this.isScanning = false;
      // 检查是否还有待处理的文件
      if (this.scanQueue.size > 0) {
        this.scheduleScan();
      }
    });
  }

  /**
   * 处理下一批文件
   */
  private async processNextBatch(): Promise<void> {
    // 取出一批文件
    const batch: string[] = [];
    let count = 0;
    
    for (const filePath of this.scanQueue) {
      batch.push(filePath);
      this.scanQueue.delete(filePath);
      count++;
      
      if (count >= this.batchSize) {
        break;
      }
    }

    if (batch.length === 0) {
      return;
    }

    // 并行处理文件
    const tasks: Promise<void>[] = [];
    const chunks = this.chunkArray(batch, Math.ceil(batch.length / this.maxConcurrentTasks));
    
    for (const chunk of chunks) {
      tasks.push(this.processFileChunk(chunk));
    }

    await Promise.all(tasks);
  }

  /**
   * 处理文件块
   */
  private async processFileChunk(files: string[]): Promise<void> {
    for (const filePath of files) {
      await this.scanFile(filePath);
    }
  }

  /**
   * 扫描单个文件
   */
  private async scanFile(filePath: string): Promise<void> {
    try {
      // 获取文件的修改时间
      const stats = await fs.stat(filePath);
      const mtimeMs = stats.mtimeMs;
      
      // 检查文件是否已扫描过且未修改
      const lastScanned = this.scannedFiles.get(filePath);
      if (lastScanned && lastScanned >= mtimeMs) {
        return;
      }
      
      // 更新扫描记录
      this.scannedFiles.set(filePath, mtimeMs);
      
      // 检查文件类型并处理
      if (filePath.endsWith('.java')) {
        await this.processJavaFile(filePath);
      } else if (filePath.endsWith('.xml')) {
        await this.processXmlFile(filePath);
      }
    } catch (error) {
      console.error(`Failed to scan file ${filePath}:`, error);
    }
  }

  /**
   * 处理 Java 文件
   */
  private async processJavaFile(filePath: string): Promise<void> {
    // 实现 Java 文件的处理逻辑
    // 检查是否为 Mapper 接口，并更新映射关系
  }

  /**
   * 处理 XML 文件
   */
  private async processXmlFile(filePath: string): Promise<void> {
    // 实现 XML 文件的处理逻辑
    // 检查是否为 MyBatis 映射文件，并更新映射关系
  }

  /**
   * 数组分块
   */
  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    
    return chunks;
  }

  /**
   * 清除扫描记录
   */
  public clearScanHistory(): void {
    this.scannedFiles.clear();
  }
}
```

### 3.3.1 扫描优化策略

1. **增量扫描**：只扫描修改过的文件，避免重复处理
2. **并行处理**：利用多核 CPU 并行处理文件，提高扫描速度
3. **批处理调度**：将文件分批处理，避免阻塞主线程
4. **智能队列管理**：根据文件优先级和依赖关系安排扫描顺序

### 3.4 重构 FileMapper 类

整合上述优化，重构 FileMapper 类，实现更高效的文件映射和跳转功能。

```typescript
/**
 * 优化后的文件映射器
 */
export class FileMapper {
  // 工具类实例
  private performanceUtils: PerformanceUtils;
  private regexUtils: RegexUtils;
  private fileUtils: FileUtils;
  private javaExtApi: JavaExtensionAPI;
  private cacheManager: AdvancedCacheManager;
  private incrementalScanner: IncrementalScanner;

  // 文件系统监听器
  private fileWatcher: vscode.FileSystemWatcher | null = null;

  // 跳转节流配置
  private readonly jumpThrottleMs: number;
  private lastJumpTime: { [key: string]: number } = {};

  // 文件打开模式
  private readonly fileOpenMode: FileOpenMode;

  constructor() {
    // 初始化工具类实例
    this.performanceUtils = PerformanceUtils.getInstance();
    this.regexUtils = RegexUtils.getInstance();
    this.fileUtils = FileUtils.getInstance();
    this.javaExtApi = JavaExtensionAPI.getInstance();
    this.cacheManager = AdvancedCacheManager.getInstance();
    this.incrementalScanner = IncrementalScanner.getInstance();

    // 从配置获取参数
    const config = getPluginConfig();
    this.jumpThrottleMs = config.jumpThrottleMs || 500;
    this.fileOpenMode = config.fileOpenMode || FileOpenMode.USE_EXISTING;
  }

  /**
   * 初始化文件映射器
   */
  public async initialize(context: vscode.ExtensionContext): Promise<void> {
    // 初始化 Java 扩展 API
    await this.javaExtApi.initialize(context);
    
    // 初始化文件系统监听
    this.setupFileWatcher(context);
    
    // 异步初始化映射关系
    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
      for (const folder of vscode.workspace.workspaceFolders) {
        this.incrementalScanner.addProjectRoot(folder.uri.fsPath);
      }
      
      // 首次扫描项目
      this.scheduleInitialScan();
    }
  }

  /**
   * 从 Mapper 接口跳转到 XML 文件
   */
  public async jumpToXml(editor: vscode.TextEditor): Promise<void> {
    const startTime = Date.now();
    try {
      // 检查是否需要节流
      if (this.shouldThrottleJump('jumpToXml')) {
        return;
      }

      const filePath = editor.document.uri.fsPath;
      const cache = this.cacheManager.getCache('javaToXml');
      
      // 优先检查缓存
      if (cache && cache.has(filePath)) {
        const xmlPath = cache.get(filePath);
        if (xmlPath && await this.fileUtils.exists(xmlPath)) {
          await this.jumpToFile(xmlPath);
          return;
        }
      }

      // 如果 Java 扩展 API 可用，使用 API 获取映射信息
      if (this.javaExtApi.isReady) {
        const methodName = this.extractMethodName(editor);
        const className = this.extractClassName(editor.document.getText());
        
        if (className) {
          const xmlPath = await this.findXmlByClassName(className);
          if (xmlPath) {
            // 更新缓存
            if (cache) {
              cache.set(filePath, xmlPath);
            }
            
            await this.jumpToFile(xmlPath, methodName);
            return;
          }
        }
      }

      // 降级到传统方式查找
      const xmlPath = await this.findXmlByQuickPath(filePath);
      if (xmlPath) {
        // 更新缓存
        if (cache) {
          cache.set(filePath, xmlPath);
        }
        
        const methodName = this.extractMethodName(editor);
        await this.jumpToFile(xmlPath, methodName);
      } else {
        // 未找到对应的 XML 文件
        vscode.window.showInformationMessage('未找到对应的 XML 文件');
      }
    } finally {
      this.performanceUtils.recordExecutionTime('FileMapper.jumpToXml', Date.now() - startTime);
    }
  }

  /**
   * 从 XML 文件跳转到 Mapper 接口
   */
  public async jumpToMapper(editor: vscode.TextEditor): Promise<void> {
    const startTime = Date.now();
    try {
      // 检查是否需要节流
      if (this.shouldThrottleJump('jumpToMapper')) {
        return;
      }

      const filePath = editor.document.uri.fsPath;
      const cache = this.cacheManager.getCache('xmlToJava');
      
      // 优先检查缓存
      if (cache && cache.has(filePath)) {
        const javaPath = cache.get(filePath);
        if (javaPath && await this.fileUtils.exists(javaPath)) {
          await this.jumpToFile(javaPath);
          return;
        }
      }

      // 提取命名空间以确定 Mapper 接口
      const namespace = await this.extractNamespace(filePath);
      if (namespace) {
        let javaPath: string | undefined;
        
        // 优先使用 Java 扩展 API 查找
        if (this.javaExtApi.isReady) {
          javaPath = await this.javaExtApi.findJavaFileByClassName(namespace);
        }
        
        // 如果 API 未找到或不可用，降级到传统方式
        if (!javaPath) {
          javaPath = await this.findJavaFileByClassName(namespace);
        }
        
        if (javaPath) {
          // 更新缓存
          if (cache) {
            cache.set(filePath, javaPath);
          }
          
          const methodName = this.extractSqlId(editor);
          await this.jumpToFile(javaPath, methodName);
          return;
        }
      }

      // 未找到对应的 Mapper 接口
      vscode.window.showInformationMessage('未找到对应的 Mapper 接口');
    } finally {
      this.performanceUtils.recordExecutionTime('FileMapper.jumpToMapper', Date.now() - startTime);
    }
  }

  // 其他方法实现...
}
```

### 3.5 添加索引机制

为 Mapper 接口和 XML 文件创建索引，使用高效的数据结构存储映射关系。通过建立类名与 XML 路径的双向映射关系，我们可以将原本需要遍历大量文件的查找操作优化为 O(1) 时间复杂度，极大提升查找性能。

```typescript
/**
 * 映射索引管理器
 */
export class MappingIndexManager {
  private static instance: MappingIndexManager;
  private classNameToXmlPath: Map<string, string> = new Map();
  private xmlPathToClassName: Map<string, string> = new Map();
  private methodToXmlLocation: Map<string, { xmlPath: string, line: number }> = new Map();
  private isIndexLoaded: boolean = false;

  private constructor() {}

  public static getInstance(): MappingIndexManager {
    if (!MappingIndexManager.instance) {
      MappingIndexManager.instance = new MappingIndexManager();
    }
    return MappingIndexManager.instance;
  }

  /**
   * 初始化索引
   */
  public async initialize(): Promise<void> {
    // 尝试从持久化存储加载索引
    await this.loadIndex();
  }

  /**
   * 添加映射关系到索引
   */
  public addMapping(className: string, xmlPath: string): void {
    this.classNameToXmlPath.set(className, xmlPath);
    this.xmlPathToClassName.set(xmlPath, className);
    
    // 异步保存索引
    this.saveIndexDebounced();
  }

  /**
   * 添加方法位置信息到索引
   */
  public addMethodLocation(className: string, methodName: string, xmlPath: string, line: number): void {
    const key = `${className}.${methodName}`;
    this.methodToXmlLocation.set(key, { xmlPath, line });
    
    // 异步保存索引
    this.saveIndexDebounced();
  }

  /**
   * 根据类名查找 XML 文件路径
   */
  public getXmlPathByClassName(className: string): string | undefined {
    return this.classNameToXmlPath.get(className);
  }

  /**
   * 根据 XML 文件路径查找类名
   */
  public getClassNameByXmlPath(xmlPath: string): string | undefined {
    return this.xmlPathToClassName.get(xmlPath);
  }

  /**
   * 根据类名和方法名查找 XML 中的位置
   */
  public getMethodLocation(className: string, methodName: string): { xmlPath: string, line: number } | undefined {
    return this.methodToXmlLocation.get(`${className}.${methodName}`);
  }

  /**
   * 移除映射关系
   */
  public removeMapping(className: string): void {
    const xmlPath = this.classNameToXmlPath.get(className);
    if (xmlPath) {
      this.classNameToXmlPath.delete(className);
      this.xmlPathToClassName.delete(xmlPath);
      
      // 移除相关的方法位置信息
      for (const key of this.methodToXmlLocation.keys()) {
        if (key.startsWith(`${className}.`)) {
          this.methodToXmlLocation.delete(key);
        }
      }
      
      // 异步保存索引
      this.saveIndexDebounced();
    }
  }

  /**
   * 清空索引
   */
  public clear(): void {
    this.classNameToXmlPath.clear();
    this.xmlPathToClassName.clear();
    this.methodToXmlLocation.clear();
    this.isIndexLoaded = false;
  }

  /**
   * 从持久化存储加载索引
   */
  private async loadIndex(): Promise<void> {
    try {
      // 实现从磁盘加载索引的逻辑
      // 例如从 VSCode 的 workspaceState 或磁盘文件加载
      this.isIndexLoaded = true;
    } catch (error) {
      console.error('Failed to load mapping index:', error);
      this.isIndexLoaded = false;
    }
  }

  /**
   * 保存索引到持久化存储
   */
  private async saveIndex(): Promise<void> {
    try {
      // 实现保存索引到磁盘的逻辑
    } catch (error) {
      console.error('Failed to save mapping index:', error);
    }
  }

  /**
   * 防抖保存索引
   */
  private saveIndexDebounced = this.debounce(() => {
    this.saveIndex();
  }, 1000);

  /**
   * 防抖函数
   */
  private debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout;
    return function(this: any, ...args: Parameters<T>) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
}
```

### 3.5.1 索引机制优化策略

1. **O(1) 时间复杂度**：通过建立类名与 XML 路径的双向映射关系，实现常数时间复杂度的查找
2. **持久化存储**：将索引数据持久化到磁盘，避免每次启动插件时重新构建索引
3. **增量更新**：当文件发生变化时，只更新相关索引项，避免全量重建
4. **内存优化**：合理设计索引数据结构，减少内存占用
5. **防抖保存**：通过防抖机制减少索引保存频率，提高性能

## 4. 实现步骤与时间计划

1. **准备阶段** (1-2天)
   - 熟悉现有代码结构和功能
   - 完善需求分析和设计文档
   - 准备开发环境和测试项目

2. **核心功能开发** (3-5天)
   - 实现 Java 扩展 API 集成模块
   - 开发高级缓存管理器
   - 实现增量扫描器
   - 开发映射索引管理器

3. **整合与重构** (2-3天)
   - 重构 FileMapper 类，整合优化功能
   - 确保与现有功能的兼容性
   - 修复可能出现的问题和冲突

4. **测试与调优** (2-3天)
   - 在不同规模的项目中进行测试
   - 性能测试和基准测试
   - 针对发现的问题进行优化

5. **文档与发布** (1-2天)
   - 更新需求分析文档
   - 更新 README 和使用指南
   - 准备发布新版本

## 5. 测试策略

1. **功能测试**
   - 验证在不同项目结构下的文件映射和跳转功能
   - 测试 Java 扩展 API 集成的稳定性
   - 测试缓存机制的正确性和有效性

2. **性能测试**
   - 在大型项目（1000+ 文件）中测试插件的性能
   - 测试首次加载和扫描的时间
   - 测试内存占用情况
   - 对比优化前后的性能差异

3. **兼容性测试**
   - 测试与不同版本的 VSCode 的兼容性
   - 测试与其他常用插件的兼容性
   - 测试在不同操作系统上的表现

## 6. 风险评估与应对措施

| 风险项 | 风险描述 | 应对措施 |
|-------|---------|---------|
| 插件兼容性 | 与 VSCode Java 扩展的版本兼容性问题 | 添加版本检测和兼容层，降级机制 |
| 性能优化失败 | 优化策略无法达到预期效果 | 预留回滚机制，保留原始实现作为备选方案 |
| 内存占用过高 | 缓存和索引机制可能导致内存占用过高 | 实现智能缓存大小控制和自动清理机制 |
| 项目结构复杂 | 复杂的项目结构可能导致映射不准确 | 提供手动映射配置功能，增强容错能力 |
| API 变更 | VSCode 或 Java 扩展 API 变更可能影响功能 | 密切关注 API 更新，及时调整实现 |
| Java 扩展依赖 | 过度依赖 Java 扩展 API 可能导致在无 Java 环境下功能受限 | 采用条件性降级策略，只有在 Java 扩展不可用时才使用传统查找机制，确保基本功能可用性 |

## 7. 预期效果

通过实施上述优化方案，预计将实现以下效果：

1. 在大型项目中，文件映射和跳转速度提升 50%-80%
2. 首次加载和扫描时间减少 40%-60%
3. 内存占用降低 30%-50%
4. 提供更流畅、更稳定的用户体验
5. 增强插件在复杂项目结构下的适应性

这些优化将使 MyBatis Helper 插件在处理大型和复杂的 MyBatis 项目时表现更加出色，为开发者提供更高效、更流畅的开发体验。

## 8. 混合方案优势总结

本混合性能优化方案结合了多种技术的优势，既保证了查找准确性，又确保了性能表现：

1. **准确性与性能并重**：优先集成 VSCode Java 扩展 API 提高查找准确性，同时保留优化的缓存机制和索引机制确保性能
2. **环境适应性强**：在有 Java 扩展的环境中优先使用 API 提升准确性，在无 Java 扩展的环境中条件性降级到传统机制保证基本功能
3. **渐进式优化**：通过增量扫描、并行处理和智能缓存等策略，实现渐进式性能提升
4. **容错能力高**：条件性降级机制确保在任何环境下都能提供基本功能
5. **可维护性好**：模块化设计使各组件职责清晰，便于后续维护和扩展